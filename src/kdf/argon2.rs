//! Argon2 - Argon2 is a Key Derivation Function algorithm, winner of the Password Hashing Competition
//!
//! This is defined in [RFC9106](https://www.rfc-editor.org/rfc/rfc9106.txt)
//!
//! The algorithm is defined by the following inputs, outputs:
//!
//! ```
//! Function Argon2
//!    Inputs:
//!       password (P):       Bytes (0..2^32-1)    Password (or message) to be hashed
//!       salt (S):           Bytes (8..2^32-1)    Salt (16 bytes recommended for password hashing)
//!       parallelism (p):    Number (1..2^24-1)   Degree of parallelism (i.e. number of threads)
//!       tagLength (T):      Number (4..2^32-1)   Desired number of returned bytes
//!       memorySizeKB (m):   Number (8p..2^32-1)  Amount of memory (in kibibytes) to use
//!       iterations (t):     Number (1..2^32-1)   Number of iterations to perform
//!       version (v):        Number (0x13)       The current version is 0x13 (19 decimal)
//!       key (K):            Bytes (0..2^32-1)    Optional key (Errata: PDF says 0..32 bytes, RFC says 0..232 bytes)
//!       associatedData (X): Bytes (0..2^32-1)    Optional arbitrary extra data
//!       hashType (y):       Number (0=Argon2d, 1=Argon2i, 2=Argon2id)
//!   Output:
//!       tag:                Bytes (tagLength)   The resulting generated bytes, tagLength bytes long
//! ```
//!

use crate::constant_time;
use crate::hashing::blake2b::{self, Blake2b};

pub struct Params {
    parallelism: u32,
    iterations: u32,
    memory_kb: u32,
    version: u32,
    hash_type: u32,
}

fn h0<const P: u32, const S: u32, const K: u32, const X: u32>(
    params: &Params,
    password: &[u8; P],
    salt: &[u8; S],
    key: &[u8; K],
    aad: &[u8; X],
    tag_length: u32,
) -> [u8; 64] {
    blake2b::Context::<512>::init()
        .update(&params.parallelism.to_le_bytes())
        .update(&tag_length.to_le_bytes())
        .update(&memory_kb.to_le_bytes())
        .update(&params.iterations.to_le_bytes())
        .update(&params.version.to_le_bytes())
        .update(&params.hash_type.to_le_bytes())
        .update(P.to_le_bytes())
        .update(password)
        .update(S.to_le_bytes())
        .update(salt)
        .update(K.to_le_bytes())
        .update(key)
        .update(X.to_le_bytes())
        .update(aad)
        .finalize()
}
